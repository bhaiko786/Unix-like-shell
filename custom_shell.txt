#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>

#define MAX_INPUT 1024
#define MAX_ARGS 64
#define MAX_PATH 256

// Function prototypes
void print_prompt();
char* read_input();
char** parse_input(char* input, int* arg_count);
int execute_command(char** args, int arg_count);
int handle_builtin(char** args);
int handle_redirection(char** args, int* arg_count);
void free_args(char** args);

int main() {
    char* input;
    char** args;
    int arg_count;
    int status;

    while (1) {
        print_prompt();
        
        input = read_input();
        if (input == NULL) {
            break;  // EOF (Ctrl+D)
        }

        // Skip empty input
        if (strlen(input) == 0) {
            free(input);
            continue;
        }

        args = parse_input(input, &arg_count);
        free(input);

        if (args == NULL || arg_count == 0) {
            continue;
        }

        // Check for exit command
        if (strcmp(args[0], "exit") == 0) {
            free_args(args);
            break;
        }

        status = execute_command(args, arg_count);
        free_args(args);
    }

    printf("Goodbye!\n");
    return 0;
}

void print_prompt() {
    char cwd[MAX_PATH];
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("%s$ ", cwd);
    } else {
        printf("shell$ ");
    }
    fflush(stdout);
}

char* read_input() {
    char* input = malloc(MAX_INPUT);
    if (input == NULL) {
        perror("malloc");
        exit(1);
    }

    if (fgets(input, MAX_INPUT, stdin) == NULL) {
        free(input);
        return NULL;
    }

    // Remove newline
    size_t len = strlen(input);
    if (len > 0 && input[len - 1] == '\n') {
        input[len - 1] = '\0';
    }

    return input;
}

char** parse_input(char* input, int* arg_count) {
    char** args = malloc(MAX_ARGS * sizeof(char*));
    if (args == NULL) {
        perror("malloc");
        exit(1);
    }

    int i = 0;
    char* token = strtok(input, " \t");
    
    while (token != NULL && i < MAX_ARGS - 1) {
        args[i] = malloc(strlen(token) + 1);
        if (args[i] == NULL) {
            perror("malloc");
            exit(1);
        }
        strcpy(args[i], token);
        i++;
        token = strtok(NULL, " \t");
    }
    
    args[i] = NULL;
    *arg_count = i;
    return args;
}

int execute_command(char** args, int arg_count) {
    // Handle built-in commands
    if (handle_builtin(args)) {
        return 0;
    }

    // Handle I/O redirection
    int redir_result = handle_redirection(args, &arg_count);
    if (redir_result < 0) {
        return -1;
    }

    pid_t pid = fork();
    
    if (pid < 0) {
        perror("fork");
        return -1;
    } else if (pid == 0) {
        // Child process
        if (execvp(args[0], args) == -1) {
            perror("execvp");
            exit(1);
        }
    } else {
        // Parent process
        int status;
        waitpid(pid, &status, 0);
        return status;
    }
    
    return 0;
}

int handle_builtin(char** args) {
    if (strcmp(args[0], "cd") == 0) {
        if (args[1] == NULL) {
            // cd with no argument goes to home
            char* home = getenv("HOME");
            if (home == NULL) {
                fprintf(stderr, "cd: HOME not set\n");
                return 1;
            }
            if (chdir(home) != 0) {
                perror("cd");
            }
        } else {
            if (chdir(args[1]) != 0) {
                perror("cd");
            }
        }
        return 1;
    } else if (strcmp(args[0], "pwd") == 0) {
        char cwd[MAX_PATH];
        if (getcwd(cwd, sizeof(cwd)) != NULL) {
            printf("%s\n", cwd);
        } else {
            perror("pwd");
        }
        return 1;
    }
    
    return 0;  // Not a built-in command
}

int handle_redirection(char** args, int* arg_count) {
    for (int i = 0; i < *arg_count; i++) {
        if (strcmp(args[i], ">") == 0) {
            // Output redirection
            if (args[i + 1] == NULL) {
                fprintf(stderr, "syntax error: expected filename after >\n");
                return -1;
            }
            
            int fd = open(args[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd < 0) {
                perror("open");
                return -1;
            }
            
            dup2(fd, STDOUT_FILENO);
            close(fd);
            
            // Remove redirection tokens from args
            free(args[i]);
            free(args[i + 1]);
            args[i] = NULL;
            *arg_count = i;
            return 0;
            
        } else if (strcmp(args[i], "<") == 0) {
            // Input redirection
            if (args[i + 1] == NULL) {
                fprintf(stderr, "syntax error: expected filename after <\n");
                return -1;
            }
            
            int fd = open(args[i + 1], O_RDONLY);
            if (fd < 0) {
                perror("open");
                return -1;
            }
            
            dup2(fd, STDIN_FILENO);
            close(fd);
            
            // Remove redirection tokens from args
            free(args[i]);
            free(args[i + 1]);
            args[i] = NULL;
            *arg_count = i;
            return 0;
            
        } else if (strcmp(args[i], ">>") == 0) {
            // Append redirection
            if (args[i + 1] == NULL) {
                fprintf(stderr, "syntax error: expected filename after >>\n");
                return -1;
            }
            
            int fd = open(args[i + 1], O_WRONLY | O_CREAT | O_APPEND, 0644);
            if (fd < 0) {
                perror("open");
                return -1;
            }
            
            dup2(fd, STDOUT_FILENO);
            close(fd);
            
            // Remove redirection tokens from args
            free(args[i]);
            free(args[i + 1]);
            args[i] = NULL;
            *arg_count = i;
            return 0;
        }
    }
    
    return 0;
}

void free_args(char** args) {
    for (int i = 0; args[i] != NULL; i++) {
        free(args[i]);
    }
    free(args);
}